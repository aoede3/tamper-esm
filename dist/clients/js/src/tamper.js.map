{"version":3,"sources":["../../../../clients/js/src/tamper.ts"],"names":[],"mappings":"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","file":"tamper.js","sourcesContent":["import type { AttributePack, ExistencePack, JsonObject, PackData } from \"./types.ts\";\n\nconst hasAtob = typeof globalThis.atob === \"function\";\nconst hasBuffer = typeof (globalThis as { Buffer?: typeof Buffer }).Buffer === \"function\";\n\nfunction decodeBase64(encoded: string): string {\n  if (hasAtob) {\n    return globalThis.atob(encoded);\n  }\n  if (hasBuffer) {\n    return (globalThis as { Buffer: typeof Buffer }).Buffer.from(encoded, \"base64\").toString(\"binary\");\n  }\n  throw new Error(\"No base64 decoder available (expected atob or Buffer).\");\n}\n\nfunction clone(obj: JsonObject): JsonObject {\n  return Object.assign({}, obj);\n}\n\nfunction extend(target: JsonObject, source: JsonObject): JsonObject {\n  return Object.assign(target, source);\n}\n\nexport const Tamper = {\n  biterate(encoded: string) {\n    const binary = decodeBase64(encoded);\n    let byteIndex = 0;\n    let bitIndex = 0;\n\n    const bitsRemaining = () => binary.length * 8 - (byteIndex * 8 + bitIndex);\n    const hasBits = (count: number): boolean => bitsRemaining() >= count;\n\n    const readBit = (): number => {\n      if (!hasBits(1)) {\n        throw new Error(\"Improperly formatted bit array\");\n      }\n      const byte = binary.charCodeAt(byteIndex);\n      const bit = (byte >> (7 - bitIndex)) & 1;\n      bitIndex += 1;\n      if (bitIndex === 8) {\n        bitIndex = 0;\n        byteIndex += 1;\n      }\n      return bit;\n    };\n\n    const readBits = (count: number): number[] => {\n      if (!hasBits(count)) {\n        throw new Error(\"Improperly formatted bit array\");\n      }\n      const bits = new Array<number>(count);\n      for (let i = 0; i < count; i += 1) {\n        bits[i] = readBit();\n      }\n      return bits;\n    };\n\n    const readNumber = (count: number): number => {\n      if (!hasBits(count)) {\n        throw new Error(\"Improperly formatted bit array\");\n      }\n      let num = 0;\n      for (let i = 0; i < count; i += 1) {\n        num = (num << 1) | readBit();\n      }\n      return num;\n    };\n\n    const readChunk = (count: number): number[] => readBits(count);\n\n    return {\n      readBit,\n      readBits,\n      readNumber,\n      readChunk,\n      hasBits,\n    };\n  },\n\n  unpackExistence(element: ExistencePack, defaultAttrs: JsonObject = {}): JsonObject[] {\n    const reader = Tamper.biterate(element.pack);\n    const output = [];\n    let counter = 0;\n\n    const consumeCC = (): number => reader.readNumber(8);\n\n    const consumeNum = (n: number) => reader.readNumber(n);\n\n    const consumeChunk = (bytes: number, bits: number) => {\n      const numBits = bytes * 8 + bits;\n      const chunk = reader.readChunk(numBits);\n      let i = 0;\n\n      while (i < numBits) {\n        if (chunk[i]) {\n          const attrs = clone(defaultAttrs);\n          output.push(extend(attrs, { guid: counter }));\n        }\n        counter += 1;\n        i += 1;\n      }\n    };\n\n    // Process control codes iteratively to avoid stack overflow\n    while (reader.hasBits(8)) {\n      const cc = consumeCC();\n      if (cc === 0) {\n        const bytesToConsume = consumeNum(32);\n        const bitsToConsume = consumeNum(8);\n        consumeChunk(bytesToConsume, bitsToConsume);\n        if (bitsToConsume > 0) {\n          reader.readBits(8 - bitsToConsume);\n        }\n      } else if (cc === 1) {\n        const numToSkip = consumeNum(32);\n        counter += numToSkip;\n      } else if (cc === 2) {\n        const numToRun = consumeNum(32);\n        for (let i = 0; i < numToRun; i += 1) {\n          const attrs = clone(defaultAttrs);\n          output.push(extend(attrs, { guid: counter }));\n          counter += 1;\n        }\n      } else {\n        throw new Error(`Unrecognised control code: ${cc}`);\n      }\n    }\n\n    return output;\n  },\n\n  unpackIntegerEncoding(element: AttributePack, numItems: number) {\n    const reader = Tamper.biterate(element.pack);\n    const bitWindowWidth = element.bit_window_width;\n    const itemWindowWidth = element.item_window_width;\n    const itemChunks = itemWindowWidth / bitWindowWidth;\n\n    const bytesToConsume = reader.readNumber(32);\n    const bitsToConsume = reader.readNumber(8);\n    let remainingBits = bytesToConsume * 8 + bitsToConsume;\n\n    const readBit = (): number => {\n      if (remainingBits <= 0) {\n        throw new Error(\"Improperly formatted bit array\");\n      }\n      remainingBits -= 1;\n      return reader.readBit();\n    };\n\n    const readNumber = (count: number): number => {\n      let num = 0;\n      for (let i = 0; i < count; i += 1) {\n        num = (num << 1) | readBit();\n      }\n      return num;\n    };\n\n    const getPossibility = (i: number): string | null =>\n      i === 0 ? null : element.possibilities[i - 1];\n    const output: Array<string | string[] | null> = new Array(numItems);\n\n    if (itemChunks > 1) {\n      for (let i = 0; i < numItems; i += 1) {\n        output[i] = [];\n      }\n    }\n\n    for (let i = 0; i < numItems; i += 1) {\n      for (let j = 0; j < itemChunks; j += 1) {\n        const possibilityId = readNumber(bitWindowWidth);\n        const result = getPossibility(possibilityId);\n        if (itemChunks === 1) {\n          output[i] = result;\n        } else if (result) {\n          (output[i] as string[]).push(result);\n        }\n      }\n    }\n\n    return output;\n  },\n\n  unpackBitmapEncoding(element: AttributePack): string[][] {\n    const reader = Tamper.biterate(element.pack);\n    const itemWindowWidth = element.item_window_width;\n    const bytesToConsume = reader.readNumber(32);\n    const bitsToConsume = reader.readNumber(8);\n    let remainingBits = bytesToConsume * 8 + bitsToConsume;\n    const chunks = remainingBits / itemWindowWidth;\n\n    const readBit = (): number => {\n      if (remainingBits <= 0) {\n        throw new Error(\"Improperly formatted bit array\");\n      }\n      remainingBits -= 1;\n      return reader.readBit();\n    };\n\n    const output: string[][] = new Array(chunks);\n    for (let i = 0; i < chunks; i += 1) {\n      output[i] = [];\n    }\n\n    for (let i = 0; i < chunks; i += 1) {\n      for (let j = 0; j < itemWindowWidth; j += 1) {\n        if (readBit() === 1) {\n          output[i].push(element.possibilities[j]);\n        }\n      }\n    }\n\n    return output;\n  },\n\n  unpackData(data: PackData, defaultAttrs: JsonObject = {}) {\n    if (data.existence) {\n      const exists = Tamper.unpackExistence(data.existence, defaultAttrs);\n\n      for (const attr of data.attributes || []) {\n        let attrArray;\n        switch (attr.encoding) {\n          case \"bitmap\":\n            attrArray = Tamper.unpackBitmapEncoding(attr);\n            break;\n          case \"integer\":\n            attrArray = Tamper.unpackIntegerEncoding(attr, exists.length);\n            break;\n          default:\n            continue;\n        }\n\n        exists.forEach((seed, i) => {\n          (seed as JsonObject)[attr.attr_name] = attrArray[i] as unknown;\n        });\n      }\n\n      return exists;\n    }\n\n    return (data.collection || []).map((item) =>\n      extend(clone(defaultAttrs), item),\n    );\n  },\n};\n\nexport function createTamper() {\n  return Tamper;\n}\n\nexport default createTamper;\n"]}