{"version":3,"sources":["../../../../encoders/js/core/utils.ts","../../../../encoders/js/core/createEncoder.ts"],"names":[],"mappings":"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","file":"createEncoder.js","sourcesContent":["function isPlainObject(value) {\n  return value !== null && typeof value === \"object\" && !Array.isArray(value);\n}\n\nexport function clone(obj) {\n  if (!obj || typeof obj !== \"object\") return obj;\n  if (Array.isArray(obj)) return obj.slice();\n  return Object.assign({}, obj);\n}\n\nexport function values(obj) {\n  return Object.keys(obj).map((key) => obj[key]);\n}\n\nexport function last(arr) {\n  return arr && arr.length ? arr[arr.length - 1] : undefined;\n}\n\nexport function sortBy(obj, iteratee) {\n  // Create array of [key, value, sortValue] to avoid recomputing\n  const entries = Object.keys(obj).map((key) => {\n    const value = obj[key];\n    return [key, value, iteratee(value, key)];\n  });\n\n  // Sort by cached sortValue\n  entries.sort((a, b) => {\n    const av = a[2];\n    const bv = b[2];\n    if (av < bv) return -1;\n    if (av > bv) return 1;\n    return 0;\n  });\n\n  // Extract values\n  return entries.map((entry) => entry[1]);\n}\n\nexport function merge(target, source) {\n  if (Array.isArray(target) && Array.isArray(source)) {\n    const max = Math.max(target.length, source.length);\n    for (let i = 0; i < max; i += 1) {\n      if (!(i in source)) continue;\n      const sourceVal = source[i];\n      const targetVal = target[i];\n      if (Array.isArray(targetVal) && Array.isArray(sourceVal)) {\n        target[i] = merge(targetVal.slice(), sourceVal);\n      } else if (isPlainObject(targetVal) && isPlainObject(sourceVal)) {\n        target[i] = merge(Object.assign({}, targetVal), sourceVal);\n      } else {\n        target[i] = sourceVal;\n      }\n    }\n    return target;\n  }\n\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach((key) => {\n      const sourceVal = source[key];\n      const targetVal = target[key];\n      if (Array.isArray(targetVal) && Array.isArray(sourceVal)) {\n        target[key] = merge(targetVal.slice(), sourceVal);\n      } else if (isPlainObject(targetVal) && isPlainObject(sourceVal)) {\n        target[key] = merge(Object.assign({}, targetVal), sourceVal);\n      } else {\n        target[key] = sourceVal;\n      }\n    });\n    return target;\n  }\n\n  return source;\n}\n","import { clone, merge, values, last, sortBy } from \"./utils.ts\";\n\ntype BufferLike = Uint8Array;\n\nexport type Bitset = {\n  length: number;\n  set(index: number, value: boolean): void;\n  setSize(size: number): void;\n  slice(begin: number, end: number): Bitset;\n  getBuffer(): BufferLike;\n};\n\ntype EncoderEnv = {\n  createBuffer(length: number): BufferLike;\n  writeUInt32BE(buffer: BufferLike, value: number, offset: number): void;\n  writeUInt8(buffer: BufferLike, value: number, offset: number): void;\n  concatBuffers(chunks: BufferLike[]): BufferLike;\n  toBase64(buffer: BufferLike): string;\n  createBitset(size: number): Bitset;\n};\n\nconst log2Cache = new Map<number, number>();\n\nfunction log2(x: number): number {\n  if (log2Cache.has(x)) {\n    return log2Cache.get(x)!;\n  }\n  const result = Math.log(x) / Math.LN2;\n  log2Cache.set(x, result);\n  return result;\n}\n\nfunction toStringKey(value: unknown): string {\n  return typeof value === \"string\" ? value : String(value);\n}\n\nexport default function createEncoder(env: EncoderEnv) {\n  type DataItem = Record<string, unknown>;\n  type AttributeOpts = {\n    attrName: string;\n    possibilities: unknown[];\n    maxChoices: number;\n    [key: string]: unknown;\n  };\n  type BufferedAttrOpts = {\n    attr_name?: string;\n    attrName?: string;\n    [key: string]: unknown;\n  };\n\n  class Bitpusher {\n    bitset: Bitset;\n    length: number;\n    capacity: number;\n\n    constructor() {\n      this.clear();\n    }\n\n    push(bit: number | boolean) {\n      const index = this.length;\n      if (bit) {\n        this.bitset.set(index, true);\n      }\n\n      this.length += 1;\n      if (this.length >= this.capacity) {\n        this.capacity = this.capacity * 2;\n        this.bitset.setSize(this.capacity);\n      }\n    }\n\n    pushMany(bit: number | boolean, howMany: number) {\n      if (howMany <= 0) return;\n      while (howMany--) this.push(bit);\n    }\n\n    clear(): void {\n      this.bitset = env.createBitset(8);\n      this.length = 0;\n      this.capacity = 8;\n    }\n\n    slice(begin: number, end: number) {\n      const bitpusher = new Bitpusher();\n      bitpusher.bitset = this.bitset.slice(begin, end);\n      bitpusher.length = end - begin;\n      return bitpusher;\n    }\n\n    getBuffer(): BufferLike {\n      return this.bitset.slice(0, this.length).getBuffer();\n    }\n\n    isEmpty(): boolean {\n      return this.length === 0;\n    }\n  }\n\n  class Pack {\n    possibilities: string[];\n    attrName: string;\n    maxChoices: number;\n    meta: Record<string, unknown>;\n    possIndex: Map<string, number>;\n    encoding: string | null;\n    bitWindowWidth: number | null;\n    itemWindowWidth: number | null;\n    buffer: BufferLike | null;\n    maxGuid: number;\n    baseOffset: number;\n    numItems: number;\n\n    constructor(\n      attrName: string,\n      possibilities: unknown[],\n      maxChoices: number,\n    ) {\n      if (!possibilities)\n        throw new Error(`Possibilities are empty for ${attrName}`);\n\n      this.possibilities = possibilities.map((a) => `${a}`);\n      this.possIndex = new Map();\n      this.possibilities.forEach((value, index) => {\n        this.possIndex.set(value, index);\n      });\n      this.attrName = attrName;\n      this.maxChoices = maxChoices;\n      this.meta = {};\n\n      this.encoding = null;\n      this.bitWindowWidth = null;\n      this.itemWindowWidth = null;\n      this.buffer = null;\n      this.maxGuid = 0;\n      this.baseOffset = 0;\n      this.numItems = 0;\n    }\n\n    toPlainObject() {\n      const output = {\n        encoding: this.encoding,\n        attr_name: this.attrName,\n        possibilities: this.possibilities,\n        pack: this.encodedBitset(),\n        item_window_width: this.itemWindowWidth,\n        bit_window_width: this.bitWindowWidth,\n        max_choices: this.maxChoices,\n        max_guid: this.maxGuid ?? 0,\n      };\n\n      return merge(output, this.meta);\n    }\n\n    finalizePack() {}\n\n    initializePack(_maxGuid: number, _numItems: number): void {}\n\n    encode(_idx: number, _data: Record<string, unknown>): void {}\n\n    encodedBitset(): string | undefined {\n      if (this.buffer && this.buffer.length) {\n        return env.toBase64(this.buffer);\n      }\n      return undefined;\n    }\n  }\n\n  class IntegerPack extends Pack {\n    static HEADER_OCTETS = 5;\n    constructor(\n      attrName: string,\n      possibilities: unknown[],\n      maxChoices: number,\n    ) {\n      super(attrName, possibilities, maxChoices);\n      this.encoding = \"integer\";\n    }\n\n    encode(idx: number, data: Record<string, unknown>) {\n      let choices = data[this.attrName] as unknown;\n      if (!Array.isArray(choices)) choices = [choices];\n\n      for (let i = 0; i < this.maxChoices; i += 1) {\n        const choiceOffset =\n          this.itemWindowWidth * idx + this.bitWindowWidth * i;\n        const value = choices[i];\n\n        const possibilityIndex = this.possIndex.get(toStringKey(value));\n        if (possibilityIndex === undefined) continue;\n\n        const possibilityId = possibilityIndex + 1;\n        const bitOffset = this.baseOffset + choiceOffset;\n\n        for (let bitPos = 0; bitPos < this.bitWindowWidth; bitPos += 1) {\n          const bitValue =\n            (possibilityId >> (this.bitWindowWidth - 1 - bitPos)) & 1;\n          const offset = bitOffset + bitPos;\n          const octetIndex = (offset / 8) | 0;\n          const mask = 1 << (7 - (offset % 8));\n          if (bitValue) {\n            this.buffer[octetIndex] |= mask;\n          } else {\n            this.buffer[octetIndex] &= ~mask;\n          }\n        }\n      }\n    }\n\n    initializePack(maxGuid: number, numItems: number) {\n      this.baseOffset = IntegerPack.HEADER_OCTETS * 8;\n\n      this.bitWindowWidth = Math.ceil(log2(this.possibilities.length + 1)) || 1;\n      this.itemWindowWidth = this.bitWindowWidth * this.maxChoices;\n\n      const bits = this.itemWindowWidth * numItems + this.baseOffset;\n      const octets = Math.ceil(bits / 8);\n      this.numItems = numItems;\n      this.buffer = env.createBuffer(octets);\n\n      const dataLength = this.itemWindowWidth * numItems;\n      const byteLength = (dataLength / 8) | 0;\n      const remainingBits = dataLength % 8;\n\n      env.writeUInt32BE(this.buffer, byteLength, 0);\n      env.writeUInt8(this.buffer, remainingBits, 4);\n    }\n  }\n\n  class BitmapPack extends Pack {\n    static HEADER_OCTETS = 5;\n    constructor(\n      attrName: string,\n      possibilities: unknown[],\n      maxChoices: number,\n    ) {\n      super(attrName, possibilities, maxChoices);\n      this.encoding = \"bitmap\";\n    }\n\n    encode(idx: number, data: Record<string, unknown>) {\n      let choices = data[this.attrName] as unknown;\n      if (!Array.isArray(choices)) choices = [choices];\n\n      const itemOffset = idx * this.itemWindowWidth;\n\n      (choices as unknown[]).forEach((choice) => {\n        const choiceOffset = this.possIndex.get(toStringKey(choice));\n        if (choiceOffset !== undefined) {\n          const offset = this.baseOffset + itemOffset + choiceOffset;\n          const octetIndex = (offset / 8) | 0;\n          const mask = 1 << (7 - (offset % 8));\n          this.buffer[octetIndex] |= mask;\n        }\n      });\n    }\n\n    initializePack(maxGuid: number, numItems: number) {\n      this.baseOffset = BitmapPack.HEADER_OCTETS * 8;\n      this.bitWindowWidth = 1;\n      this.itemWindowWidth = this.possibilities.length;\n\n      const bits = this.itemWindowWidth * numItems + this.baseOffset;\n      const octets = Math.ceil(bits / 8);\n\n      this.buffer = env.createBuffer(octets);\n\n      const dataLength = this.itemWindowWidth * numItems;\n      const byteLength = (dataLength / 8) | 0;\n      const remainingBits = dataLength % 8;\n\n      env.writeUInt32BE(this.buffer, byteLength, 0);\n      env.writeUInt8(this.buffer, remainingBits, 4);\n    }\n  }\n\n  class ExistencePack extends Pack {\n    static KEEP = 0x00;\n    static SKIP = 0x01;\n    static RUN = 0x02;\n    lastGuid: number;\n    runCounter: number;\n    bitpusher: Bitpusher;\n    outputBuffers: BufferLike[];\n    controlCodes: Array<{ type: \"keep\" | \"skip\" | \"run\"; offset: number; buffer?: BufferLike }>;\n    output?: unknown;\n\n    constructor() {\n      super(\"existence\", [\"existence\"], 1);\n      this.encoding = \"existence\";\n      this.lastGuid = 0;\n      this.runCounter = 0;\n      this.bitpusher = new Bitpusher();\n      this.outputBuffers = [];\n      this.controlCodes = [];\n    }\n\n    initializePack(_maxGuid: number, _numItems: number): void {}\n\n    encode(guid: number) {\n      let guidDiff = guid - this.lastGuid;\n\n      if (this.bitpusher.isEmpty() && !this.output && guid > 0) {\n        guidDiff += 1;\n      }\n\n      if (guidDiff === 1 || guid === 0) {\n        this.bitpusher.push(1);\n        this.runCounter += 1;\n      } else if (guidDiff <= 0) {\n        throw new Error(\n          `Error: data was not sorted by GUID (got ${this.lastGuid}, then ${guid})!`,\n        );\n      } else if (guidDiff > 40) {\n        this.dumpKeep(this.bitpusher, this.runCounter);\n\n        this.controlCodes.push({ type: \"skip\", offset: guidDiff - 1 });\n\n        this.bitpusher.clear();\n        this.bitpusher.push(1);\n        this.runCounter = 1;\n      } else {\n        if (this.runCounter > 40) {\n          this.dumpKeep(this.bitpusher, this.runCounter);\n          this.bitpusher.clear();\n          this.runCounter = 0;\n        }\n\n        this.bitpusher.pushMany(0, guidDiff - 1);\n        this.bitpusher.push(1);\n        this.runCounter = 1;\n      }\n\n      this.lastGuid = guid;\n    }\n\n    finalizePack(): void {\n      this.dumpKeep(this.bitpusher, this.runCounter);\n\n      // Calculate total buffer size needed\n      let totalSize = 0;\n      for (const cc of this.controlCodes) {\n        if (cc.type === \"keep\") {\n          totalSize += 6; // keep control code\n          totalSize += cc.buffer?.length || 0; // plus data buffer\n        } else {\n          totalSize += 5; // skip or run control code\n        }\n      }\n\n      // Allocate single buffer and write all control codes\n      this.buffer = env.createBuffer(totalSize);\n      let offset = 0;\n\n      for (const cc of this.controlCodes) {\n        if (cc.type === \"keep\") {\n          const bytesToKeep = Math.floor(cc.offset / 8);\n          const remainingBits = cc.offset % 8;\n          env.writeUInt8(this.buffer, ExistencePack.KEEP, offset);\n          env.writeUInt32BE(this.buffer, bytesToKeep, offset + 1);\n          env.writeUInt8(this.buffer, remainingBits, offset + 5);\n          offset += 6;\n\n          if (cc.buffer) {\n            for (let i = 0; i < cc.buffer.length; i++) {\n              this.buffer[offset++] = cc.buffer[i];\n            }\n          }\n        } else if (cc.type === \"skip\") {\n          env.writeUInt8(this.buffer, ExistencePack.SKIP, offset);\n          env.writeUInt32BE(this.buffer, cc.offset, offset + 1);\n          offset += 5;\n        } else if (cc.type === \"run\") {\n          env.writeUInt8(this.buffer, ExistencePack.RUN, offset);\n          env.writeUInt32BE(this.buffer, cc.offset, offset + 1);\n          offset += 5;\n        }\n      }\n    }\n\n    toPlainObject(): Record<string, unknown> {\n      return {\n        attr_name: \"existence\",\n        display_name: \"\",\n        max_choices: 0,\n        possibilities: null,\n        filter_type: \"\",\n        display_type: \"\",\n        encoding: this.encoding,\n        pack: this.encodedBitset(),\n        bit_window_width: 0,\n        item_window_width: 0,\n        max_guid: this.maxGuid ?? 0,\n      };\n    }\n\n    dumpKeep(bitpusher: Bitpusher, runLen: number) {\n      if (runLen >= 40) {\n        const length = bitpusher.length - runLen;\n        if (length > 0) {\n          // Directly slice the bitset for the buffer, avoiding intermediate Bitpusher\n          const keepBuffer = bitpusher.bitset.slice(0, length).getBuffer();\n          this.controlCodes.push({\n            type: \"keep\",\n            offset: length,\n            buffer: keepBuffer\n          });\n        }\n        this.controlCodes.push({ type: \"run\", offset: runLen });\n      } else if (bitpusher.length > 0) {\n        this.controlCodes.push({\n          type: \"keep\",\n          offset: bitpusher.length,\n          buffer: bitpusher.getBuffer()\n        });\n      }\n    }\n\n    controlCode(cmd: \"keep\" | \"skip\" | \"run\", offset = 0): BufferLike {\n      let buffer: BufferLike;\n\n      switch (cmd) {\n        case \"keep\": {\n          const bytesToKeep = Math.floor(offset / 8);\n          const remainingBits = offset % 8;\n\n          buffer = env.createBuffer(6);\n          env.writeUInt8(buffer, ExistencePack.KEEP, 0);\n          env.writeUInt32BE(buffer, bytesToKeep, 1);\n          env.writeUInt8(buffer, remainingBits, 5);\n          break;\n        }\n        case \"skip\":\n          buffer = env.createBuffer(5);\n          env.writeUInt8(buffer, ExistencePack.SKIP, 0);\n          env.writeUInt32BE(buffer, offset, 1);\n          break;\n        case \"run\":\n          buffer = env.createBuffer(5);\n          env.writeUInt8(buffer, ExistencePack.RUN, 0);\n          env.writeUInt32BE(buffer, offset, 1);\n          break;\n        default:\n          throw new Error(`Unknown control command: ${cmd}!`);\n      }\n\n      return buffer;\n    }\n  }\n\n  class PackSet {\n    static DEFAULT_GUID_ATTR = \"id\";\n    meta: Record<string, unknown>;\n    existencePack: ExistencePack;\n    attrPacks: Record<string, Pack>;\n    bufferedAttrs: Record<string, Record<string, unknown>>;\n\n    constructor(opts: Record<string, unknown> = {}) {\n      this.meta = {};\n      this.existencePack = new ExistencePack();\n      this.attrPacks = {};\n      this.bufferedAttrs = {};\n      this.meta = opts;\n    }\n\n    addAttribute(opts: AttributeOpts) {\n      [\"attrName\", \"possibilities\", \"maxChoices\"].forEach((requiredOpt) => {\n        if (opts[requiredOpt] === undefined) {\n          throw new Error(\n            `${requiredOpt} is required when adding an attribute!`,\n          );\n        }\n      });\n\n      const localOpts = clone(opts) as AttributeOpts;\n      const name = localOpts.attrName;\n      delete localOpts.attrName;\n\n      const possibilities = localOpts.possibilities;\n      delete localOpts.possibilities;\n\n      const maxChoices = localOpts.maxChoices;\n      delete localOpts.maxChoices;\n\n      const pack = createPack(\n        name as string,\n        possibilities as unknown[],\n        maxChoices as number,\n      );\n      pack.meta = localOpts;\n\n      this.attrPacks[name] = pack;\n\n      return pack;\n    }\n\n    addBufferedAttribute(opts: BufferedAttrOpts) {\n      const localOpts = clone(opts) as BufferedAttrOpts;\n      const attrName = (localOpts.attrName ?? localOpts.attr_name) as string;\n      if (attrName === undefined) {\n        throw new Error(\n          \"attrName or attr_name is required when adding a buffered attribute!\",\n        );\n      }\n\n      delete localOpts.attrName;\n      delete localOpts.attr_name;\n\n      this.bufferedAttrs[attrName] = merge({ attrName }, localOpts);\n    }\n\n    attributes() {\n      return Object.keys(this.attrPacks);\n    }\n\n    packFor(attr: string) {\n      return this.attrPacks[attr];\n    }\n\n    pack(data: DataItem[], opts: Record<string, unknown> = {}) {\n      const localOpts = (clone(opts) || {}) as Record<string, unknown>;\n\n      if (localOpts.guidAttr == null) {\n        localOpts.guidAttr = PackSet.DEFAULT_GUID_ATTR;\n      }\n      const guidAttr = localOpts.guidAttr as string;\n      if (localOpts.maxGuid == null) {\n        localOpts.maxGuid = (last(data) as DataItem)[guidAttr];\n      }\n      if (localOpts.numItems == null) {\n        localOpts.numItems = data.length;\n      }\n\n      this.buildPack(localOpts, data);\n    }\n\n    buildPack(opts: Record<string, unknown> = {}, items: DataItem[]) {\n      [\"numItems\", \"maxGuid\"].forEach((requiredOpt) => {\n        if (opts[requiredOpt] === undefined) {\n          throw new Error(\n            `You must specify ${requiredOpt} to start building a pack!`,\n          );\n        }\n      });\n\n      const existencePack = this.existencePack;\n      const numItems = opts.numItems as number;\n      const maxGuid = opts.maxGuid as number;\n      const guidAttr = (opts.guidAttr as string) || PackSet.DEFAULT_GUID_ATTR;\n      const packs = values(this.attrPacks) as Pack[];\n\n      existencePack.initializePack(maxGuid, numItems);\n      existencePack.maxGuid = 0;\n      packs.forEach((pack) => {\n        pack.initializePack(maxGuid, numItems);\n        pack.maxGuid = 0;\n      });\n\n      let idx = 0;\n\n      items.forEach((item) => {\n        const guid = item[guidAttr] as number;\n\n        existencePack.encode(guid);\n\n        packs.forEach((pack) => {\n          pack.encode(idx, item);\n        });\n\n        idx += 1;\n      });\n\n      existencePack.finalizePack();\n      packs.forEach((pack) => pack.finalizePack());\n    }\n\n    buildUnorderedPack(opts: Record<string, unknown>, items: DataItem[]) {\n      const guidAttr = (opts.guidAttr as string) || \"id\";\n      const data: Record<string, DataItem> = {};\n\n      items.forEach((item) => {\n        const guid = item[guidAttr] as string | number;\n        data[String(guid)] = item;\n      });\n\n      const sortedData = sortBy(data, (d, key) => key) as DataItem[];\n      this.pack(sortedData, opts);\n    }\n\n    toPlainObject(opts: Record<string, unknown> = {}) {\n      const attributes = values(this.attrPacks).map((pack) => pack.toPlainObject());\n      const buffered = values(this.bufferedAttrs) as Record<string, unknown>[];\n\n      const output = {\n        existence: this.existencePack.toPlainObject(),\n        attributes: attributes.concat(buffered),\n      };\n\n      return merge(output, this.meta);\n    }\n\n    toJSON(): string {\n      return JSON.stringify(this.toPlainObject());\n    }\n  }\n\n  function createPack(\n    attrName: string,\n    possibilities: unknown[],\n    maxChoices: number,\n  ) {\n    let PackConstructor;\n\n    if (maxChoices * log2(possibilities.length) < possibilities.length) {\n      PackConstructor = IntegerPack;\n    } else {\n      PackConstructor = BitmapPack;\n    }\n\n    return new PackConstructor(attrName, possibilities, maxChoices);\n  }\n\n  function createPackSet(): PackSet {\n    return new PackSet();\n  }\n\n  return {\n    Bitpusher,\n    createPackSet,\n    PackSet,\n    createPack,\n    Pack,\n    IntegerPack,\n    BitmapPack,\n    ExistencePack,\n  };\n}\n"]}