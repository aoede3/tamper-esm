{"version":3,"sources":["../../../../encoders/js/core/utils.ts"],"names":[],"mappings":"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","file":"utils.js","sourcesContent":["function isPlainObject(value) {\n  return value !== null && typeof value === \"object\" && !Array.isArray(value);\n}\n\nexport function clone(obj) {\n  if (!obj || typeof obj !== \"object\") return obj;\n  if (Array.isArray(obj)) return obj.slice();\n  return Object.assign({}, obj);\n}\n\nexport function values(obj) {\n  return Object.keys(obj).map((key) => obj[key]);\n}\n\nexport function last(arr) {\n  return arr && arr.length ? arr[arr.length - 1] : undefined;\n}\n\nexport function sortBy(obj, iteratee) {\n  // Create array of [key, value, sortValue] to avoid recomputing\n  const entries = Object.keys(obj).map((key) => {\n    const value = obj[key];\n    return [key, value, iteratee(value, key)];\n  });\n\n  // Sort by cached sortValue\n  entries.sort((a, b) => {\n    const av = a[2];\n    const bv = b[2];\n    if (av < bv) return -1;\n    if (av > bv) return 1;\n    return 0;\n  });\n\n  // Extract values\n  return entries.map((entry) => entry[1]);\n}\n\nexport function merge(target, source) {\n  if (Array.isArray(target) && Array.isArray(source)) {\n    const max = Math.max(target.length, source.length);\n    for (let i = 0; i < max; i += 1) {\n      if (!(i in source)) continue;\n      const sourceVal = source[i];\n      const targetVal = target[i];\n      if (Array.isArray(targetVal) && Array.isArray(sourceVal)) {\n        target[i] = merge(targetVal.slice(), sourceVal);\n      } else if (isPlainObject(targetVal) && isPlainObject(sourceVal)) {\n        target[i] = merge(Object.assign({}, targetVal), sourceVal);\n      } else {\n        target[i] = sourceVal;\n      }\n    }\n    return target;\n  }\n\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach((key) => {\n      const sourceVal = source[key];\n      const targetVal = target[key];\n      if (Array.isArray(targetVal) && Array.isArray(sourceVal)) {\n        target[key] = merge(targetVal.slice(), sourceVal);\n      } else if (isPlainObject(targetVal) && isPlainObject(sourceVal)) {\n        target[key] = merge(Object.assign({}, targetVal), sourceVal);\n      } else {\n        target[key] = sourceVal;\n      }\n    });\n    return target;\n  }\n\n  return source;\n}\n"]}