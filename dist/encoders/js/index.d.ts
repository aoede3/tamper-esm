import { Bitset } from './core/createEncoder.js';

declare const createPackSet: () => {
    meta: Record<string, unknown>;
    existencePack: {
        lastGuid: number;
        runCounter: number;
        bitpusher: {
            bitset: Bitset;
            length: number;
            capacity: number;
            push(bit: number | boolean): void;
            pushMany(bit: number | boolean, howMany: number): void;
            clear(): void;
            slice(begin: number, end: number): /*elided*/ any;
            getBuffer(): Uint8Array<ArrayBufferLike>;
            isEmpty(): boolean;
        };
        outputBuffers: Uint8Array<ArrayBufferLike>[];
        controlCodes: Array<{
            type: "keep" | "skip" | "run";
            offset: number;
            buffer?: Uint8Array<ArrayBufferLike>;
        }>;
        output?: unknown;
        initializePack(_maxGuid: number, _numItems: number): void;
        encode(guid: number): void;
        finalizePack(): void;
        toPlainObject(): Record<string, unknown>;
        dumpKeep(bitpusher: {
            bitset: Bitset;
            length: number;
            capacity: number;
            push(bit: number | boolean): void;
            pushMany(bit: number | boolean, howMany: number): void;
            clear(): void;
            slice(begin: number, end: number): /*elided*/ any;
            getBuffer(): Uint8Array<ArrayBufferLike>;
            isEmpty(): boolean;
        }, runLen: number): void;
        controlCode(cmd: "keep" | "skip" | "run", offset?: number): Uint8Array<ArrayBufferLike>;
        possibilities: string[];
        attrName: string;
        maxChoices: number;
        meta: Record<string, unknown>;
        possIndex: Map<string, number>;
        encoding: string | null;
        bitWindowWidth: number | null;
        itemWindowWidth: number | null;
        buffer: Uint8Array<ArrayBufferLike> | null;
        maxGuid: number;
        baseOffset: number;
        numItems: number;
        encodedBitset(): string | undefined;
    };
    attrPacks: Record<string, {
        possibilities: string[];
        attrName: string;
        maxChoices: number;
        meta: Record<string, unknown>;
        possIndex: Map<string, number>;
        encoding: string | null;
        bitWindowWidth: number | null;
        itemWindowWidth: number | null;
        buffer: Uint8Array<ArrayBufferLike> | null;
        maxGuid: number;
        baseOffset: number;
        numItems: number;
        toPlainObject(): any;
        finalizePack(): void;
        initializePack(_maxGuid: number, _numItems: number): void;
        encode(_idx: number, _data: Record<string, unknown>): void;
        encodedBitset(): string | undefined;
    }>;
    bufferedAttrs: Record<string, Record<string, unknown>>;
    addAttribute(opts: {
        [key: string]: unknown;
        attrName: string;
        possibilities: unknown[];
        maxChoices: number;
    }): any;
    addBufferedAttribute(opts: {
        [key: string]: unknown;
        attr_name?: string;
        attrName?: string;
    }): void;
    attributes(): string[];
    packFor(attr: string): {
        possibilities: string[];
        attrName: string;
        maxChoices: number;
        meta: Record<string, unknown>;
        possIndex: Map<string, number>;
        encoding: string | null;
        bitWindowWidth: number | null;
        itemWindowWidth: number | null;
        buffer: Uint8Array<ArrayBufferLike> | null;
        maxGuid: number;
        baseOffset: number;
        numItems: number;
        toPlainObject(): any;
        finalizePack(): void;
        initializePack(_maxGuid: number, _numItems: number): void;
        encode(_idx: number, _data: Record<string, unknown>): void;
        encodedBitset(): string | undefined;
    };
    pack(data: Record<string, unknown>[], opts?: Record<string, unknown>): void;
    buildPack(opts: Record<string, unknown>, items: Record<string, unknown>[]): void;
    buildUnorderedPack(opts: Record<string, unknown>, items: Record<string, unknown>[]): void;
    toPlainObject(opts?: Record<string, unknown>): any;
    toJSON(): string;
};
declare const PackSet: {
    new (opts?: Record<string, unknown>): {
        meta: Record<string, unknown>;
        existencePack: {
            lastGuid: number;
            runCounter: number;
            bitpusher: {
                bitset: Bitset;
                length: number;
                capacity: number;
                push(bit: number | boolean): void;
                pushMany(bit: number | boolean, howMany: number): void;
                clear(): void;
                slice(begin: number, end: number): /*elided*/ any;
                getBuffer(): Uint8Array<ArrayBufferLike>;
                isEmpty(): boolean;
            };
            outputBuffers: Uint8Array<ArrayBufferLike>[];
            controlCodes: Array<{
                type: "keep" | "skip" | "run";
                offset: number;
                buffer?: Uint8Array<ArrayBufferLike>;
            }>;
            output?: unknown;
            initializePack(_maxGuid: number, _numItems: number): void;
            encode(guid: number): void;
            finalizePack(): void;
            toPlainObject(): Record<string, unknown>;
            dumpKeep(bitpusher: {
                bitset: Bitset;
                length: number;
                capacity: number;
                push(bit: number | boolean): void;
                pushMany(bit: number | boolean, howMany: number): void;
                clear(): void;
                slice(begin: number, end: number): /*elided*/ any;
                getBuffer(): Uint8Array<ArrayBufferLike>;
                isEmpty(): boolean;
            }, runLen: number): void;
            controlCode(cmd: "keep" | "skip" | "run", offset?: number): Uint8Array<ArrayBufferLike>;
            possibilities: string[];
            attrName: string;
            maxChoices: number;
            meta: Record<string, unknown>;
            possIndex: Map<string, number>;
            encoding: string | null;
            bitWindowWidth: number | null;
            itemWindowWidth: number | null;
            buffer: Uint8Array<ArrayBufferLike> | null;
            maxGuid: number;
            baseOffset: number;
            numItems: number;
            encodedBitset(): string | undefined;
        };
        attrPacks: Record<string, {
            possibilities: string[];
            attrName: string;
            maxChoices: number;
            meta: Record<string, unknown>;
            possIndex: Map<string, number>;
            encoding: string | null;
            bitWindowWidth: number | null;
            itemWindowWidth: number | null;
            buffer: Uint8Array<ArrayBufferLike> | null;
            maxGuid: number;
            baseOffset: number;
            numItems: number;
            toPlainObject(): any;
            finalizePack(): void;
            initializePack(_maxGuid: number, _numItems: number): void;
            encode(_idx: number, _data: Record<string, unknown>): void;
            encodedBitset(): string | undefined;
        }>;
        bufferedAttrs: Record<string, Record<string, unknown>>;
        addAttribute(opts: {
            [key: string]: unknown;
            attrName: string;
            possibilities: unknown[];
            maxChoices: number;
        }): any;
        addBufferedAttribute(opts: {
            [key: string]: unknown;
            attr_name?: string;
            attrName?: string;
        }): void;
        attributes(): string[];
        packFor(attr: string): {
            possibilities: string[];
            attrName: string;
            maxChoices: number;
            meta: Record<string, unknown>;
            possIndex: Map<string, number>;
            encoding: string | null;
            bitWindowWidth: number | null;
            itemWindowWidth: number | null;
            buffer: Uint8Array<ArrayBufferLike> | null;
            maxGuid: number;
            baseOffset: number;
            numItems: number;
            toPlainObject(): any;
            finalizePack(): void;
            initializePack(_maxGuid: number, _numItems: number): void;
            encode(_idx: number, _data: Record<string, unknown>): void;
            encodedBitset(): string | undefined;
        };
        pack(data: Record<string, unknown>[], opts?: Record<string, unknown>): void;
        buildPack(opts: Record<string, unknown>, items: Record<string, unknown>[]): void;
        buildUnorderedPack(opts: Record<string, unknown>, items: Record<string, unknown>[]): void;
        toPlainObject(opts?: Record<string, unknown>): any;
        toJSON(): string;
    };
    DEFAULT_GUID_ATTR: string;
};
declare const createPack: (attrName: string, possibilities: unknown[], maxChoices: number) => any;
declare const Pack: {
    new (attrName: string, possibilities: unknown[], maxChoices: number): {
        possibilities: string[];
        attrName: string;
        maxChoices: number;
        meta: Record<string, unknown>;
        possIndex: Map<string, number>;
        encoding: string | null;
        bitWindowWidth: number | null;
        itemWindowWidth: number | null;
        buffer: Uint8Array<ArrayBufferLike> | null;
        maxGuid: number;
        baseOffset: number;
        numItems: number;
        toPlainObject(): any;
        finalizePack(): void;
        initializePack(_maxGuid: number, _numItems: number): void;
        encode(_idx: number, _data: Record<string, unknown>): void;
        encodedBitset(): string | undefined;
    };
};
declare const IntegerPack: {
    new (attrName: string, possibilities: unknown[], maxChoices: number): {
        encode(idx: number, data: Record<string, unknown>): void;
        initializePack(maxGuid: number, numItems: number): void;
        possibilities: string[];
        attrName: string;
        maxChoices: number;
        meta: Record<string, unknown>;
        possIndex: Map<string, number>;
        encoding: string | null;
        bitWindowWidth: number | null;
        itemWindowWidth: number | null;
        buffer: Uint8Array<ArrayBufferLike> | null;
        maxGuid: number;
        baseOffset: number;
        numItems: number;
        toPlainObject(): any;
        finalizePack(): void;
        encodedBitset(): string | undefined;
    };
    HEADER_OCTETS: number;
};
declare const BitmapPack: {
    new (attrName: string, possibilities: unknown[], maxChoices: number): {
        encode(idx: number, data: Record<string, unknown>): void;
        initializePack(maxGuid: number, numItems: number): void;
        possibilities: string[];
        attrName: string;
        maxChoices: number;
        meta: Record<string, unknown>;
        possIndex: Map<string, number>;
        encoding: string | null;
        bitWindowWidth: number | null;
        itemWindowWidth: number | null;
        buffer: Uint8Array<ArrayBufferLike> | null;
        maxGuid: number;
        baseOffset: number;
        numItems: number;
        toPlainObject(): any;
        finalizePack(): void;
        encodedBitset(): string | undefined;
    };
    HEADER_OCTETS: number;
};
declare const ExistencePack: {
    new (): {
        lastGuid: number;
        runCounter: number;
        bitpusher: {
            bitset: Bitset;
            length: number;
            capacity: number;
            push(bit: number | boolean): void;
            pushMany(bit: number | boolean, howMany: number): void;
            clear(): void;
            slice(begin: number, end: number): /*elided*/ any;
            getBuffer(): Uint8Array<ArrayBufferLike>;
            isEmpty(): boolean;
        };
        outputBuffers: Uint8Array<ArrayBufferLike>[];
        controlCodes: Array<{
            type: "keep" | "skip" | "run";
            offset: number;
            buffer?: Uint8Array<ArrayBufferLike>;
        }>;
        output?: unknown;
        initializePack(_maxGuid: number, _numItems: number): void;
        encode(guid: number): void;
        finalizePack(): void;
        toPlainObject(): Record<string, unknown>;
        dumpKeep(bitpusher: {
            bitset: Bitset;
            length: number;
            capacity: number;
            push(bit: number | boolean): void;
            pushMany(bit: number | boolean, howMany: number): void;
            clear(): void;
            slice(begin: number, end: number): /*elided*/ any;
            getBuffer(): Uint8Array<ArrayBufferLike>;
            isEmpty(): boolean;
        }, runLen: number): void;
        controlCode(cmd: "keep" | "skip" | "run", offset?: number): Uint8Array<ArrayBufferLike>;
        possibilities: string[];
        attrName: string;
        maxChoices: number;
        meta: Record<string, unknown>;
        possIndex: Map<string, number>;
        encoding: string | null;
        bitWindowWidth: number | null;
        itemWindowWidth: number | null;
        buffer: Uint8Array<ArrayBufferLike> | null;
        maxGuid: number;
        baseOffset: number;
        numItems: number;
        encodedBitset(): string | undefined;
    };
    KEEP: number;
    SKIP: number;
    RUN: number;
};
declare const Bitpusher: {
    new (): {
        bitset: Bitset;
        length: number;
        capacity: number;
        push(bit: number | boolean): void;
        pushMany(bit: number | boolean, howMany: number): void;
        clear(): void;
        slice(begin: number, end: number): /*elided*/ any;
        getBuffer(): Uint8Array<ArrayBufferLike>;
        isEmpty(): boolean;
    };
};

export { BitmapPack, Bitpusher, ExistencePack, IntegerPack, Pack, PackSet, createPack, createPackSet };
